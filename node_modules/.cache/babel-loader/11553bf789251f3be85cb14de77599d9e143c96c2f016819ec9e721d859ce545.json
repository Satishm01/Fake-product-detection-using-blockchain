{"ast":null,"code":"\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, splitSignature, stripZeros } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport var TransactionTypes;\n(function (TransactionTypes) {\n  TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n  TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n  TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n})(TransactionTypes || (TransactionTypes = {}));\n;\n///////////////////////////////\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n  return getAddress(value);\n}\nfunction handleNumber(value) {\n  if (value === \"0x\") {\n    return Zero;\n  }\n  return BigNumber.from(value);\n}\n// Legacy Transaction Fields\nconst transactionFields = [{\n  name: \"nonce\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"gasPrice\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"gasLimit\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"to\",\n  length: 20\n}, {\n  name: \"value\",\n  maxLength: 32,\n  numeric: true\n}, {\n  name: \"data\"\n}];\nconst allowedTransactionKeys = {\n  chainId: true,\n  data: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  type: true,\n  value: true\n};\nexport function computeAddress(key) {\n  const publicKey = computePublicKey(key);\n  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\nexport function recoverAddress(digest, signature) {\n  return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\nfunction formatNumber(value, name) {\n  const result = stripZeros(BigNumber.from(value).toHexString());\n  if (result.length > 32) {\n    logger.throwArgumentError(\"invalid length for \" + name, \"transaction:\" + name, value);\n  }\n  return result;\n}\nfunction accessSetify(addr, storageKeys) {\n  return {\n    address: getAddress(addr),\n    storageKeys: (storageKeys || []).map((storageKey, index) => {\n      if (hexDataLength(storageKey) !== 32) {\n        logger.throwArgumentError(\"invalid access list storageKey\", \"accessList[\".concat(addr, \":\").concat(index, \"]\"), storageKey);\n      }\n      return storageKey.toLowerCase();\n    })\n  };\n}\nexport function accessListify(value) {\n  if (Array.isArray(value)) {\n    return value.map((set, index) => {\n      if (Array.isArray(set)) {\n        if (set.length > 2) {\n          logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", \"value[\".concat(index, \"]\"), set);\n        }\n        return accessSetify(set[0], set[1]);\n      }\n      return accessSetify(set.address, set.storageKeys);\n    });\n  }\n  const result = Object.keys(value).map(addr => {\n    const storageKeys = value[addr].reduce((accum, storageKey) => {\n      accum[storageKey] = true;\n      return accum;\n    }, {});\n    return accessSetify(addr, Object.keys(storageKeys).sort());\n  });\n  result.sort((a, b) => a.address.localeCompare(b.address));\n  return result;\n}\nfunction formatAccessList(value) {\n  return accessListify(value).map(set => [set.address, set.storageKeys]);\n}\nfunction _serializeEip1559(transaction, signature) {\n  // If there is an explicit gasPrice, make sure it matches the\n  // EIP-1559 fees; otherwise they may not understand what they\n  // think they are setting in terms of fee.\n  if (transaction.gasPrice != null) {\n    const gasPrice = BigNumber.from(transaction.gasPrice);\n    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n    if (!gasPrice.eq(maxFeePerGas)) {\n      logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n        gasPrice,\n        maxFeePerGas\n      });\n    }\n  }\n  const fields = [formatNumber(transaction.chainId || 0, \"chainId\"), formatNumber(transaction.nonce || 0, \"nonce\"), formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(transaction.gasLimit || 0, \"gasLimit\"), transaction.to != null ? getAddress(transaction.to) : \"0x\", formatNumber(transaction.value || 0, \"value\"), transaction.data || \"0x\", formatAccessList(transaction.accessList || [])];\n  if (signature) {\n    const sig = splitSignature(signature);\n    fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n    fields.push(stripZeros(sig.r));\n    fields.push(stripZeros(sig.s));\n  }\n  return hexConcat([\"0x02\", RLP.encode(fields)]);\n}\nfunction _serializeEip2930(transaction, signature) {\n  const fields = [formatNumber(transaction.chainId || 0, \"chainId\"), formatNumber(transaction.nonce || 0, \"nonce\"), formatNumber(transaction.gasPrice || 0, \"gasPrice\"), formatNumber(transaction.gasLimit || 0, \"gasLimit\"), transaction.to != null ? getAddress(transaction.to) : \"0x\", formatNumber(transaction.value || 0, \"value\"), transaction.data || \"0x\", formatAccessList(transaction.accessList || [])];\n  if (signature) {\n    const sig = splitSignature(signature);\n    fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n    fields.push(stripZeros(sig.r));\n    fields.push(stripZeros(sig.s));\n  }\n  return hexConcat([\"0x01\", RLP.encode(fields)]);\n}\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction, signature) {\n  checkProperties(transaction, allowedTransactionKeys);\n  const raw = [];\n  transactionFields.forEach(function (fieldInfo) {\n    let value = transaction[fieldInfo.name] || [];\n    const options = {};\n    if (fieldInfo.numeric) {\n      options.hexPad = \"left\";\n    }\n    value = arrayify(hexlify(value, options));\n    // Fixed-width field\n    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n      logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n    }\n    // Variable-width (with a maximum)\n    if (fieldInfo.maxLength) {\n      value = stripZeros(value);\n      if (value.length > fieldInfo.maxLength) {\n        logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n      }\n    }\n    raw.push(hexlify(value));\n  });\n  let chainId = 0;\n  if (transaction.chainId != null) {\n    // A chainId was provided; if non-zero we'll use EIP-155\n    chainId = transaction.chainId;\n    if (typeof chainId !== \"number\") {\n      logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n    }\n  } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n    // No chainId provided, but the signature is signing with EIP-155; derive chainId\n    chainId = Math.floor((signature.v - 35) / 2);\n  }\n  // We have an EIP-155 transaction (chainId was specified and non-zero)\n  if (chainId !== 0) {\n    raw.push(hexlify(chainId)); // @TODO: hexValue?\n    raw.push(\"0x\");\n    raw.push(\"0x\");\n  }\n  // Requesting an unsigned transaction\n  if (!signature) {\n    return RLP.encode(raw);\n  }\n  // The splitSignature will ensure the transaction has a recoveryParam in the\n  // case that the signTransaction function only adds a v.\n  const sig = splitSignature(signature);\n  // We pushed a chainId and null r, s on for hashing only; remove those\n  let v = 27 + sig.recoveryParam;\n  if (chainId !== 0) {\n    raw.pop();\n    raw.pop();\n    raw.pop();\n    v += chainId * 2 + 8;\n    // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n    if (sig.v > 28 && sig.v !== v) {\n      logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n  } else if (sig.v !== v) {\n    logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n  }\n  raw.push(hexlify(v));\n  raw.push(stripZeros(arrayify(sig.r)));\n  raw.push(stripZeros(arrayify(sig.s)));\n  return RLP.encode(raw);\n}\nexport function serialize(transaction, signature) {\n  // Legacy and EIP-155 Transactions\n  if (transaction.type == null || transaction.type === 0) {\n    if (transaction.accessList != null) {\n      logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n    }\n    return _serialize(transaction, signature);\n  }\n  // Typed Transactions (EIP-2718)\n  switch (transaction.type) {\n    case 1:\n      return _serializeEip2930(transaction, signature);\n    case 2:\n      return _serializeEip1559(transaction, signature);\n    default:\n      break;\n  }\n  return logger.throwError(\"unsupported transaction type: \".concat(transaction.type), Logger.errors.UNSUPPORTED_OPERATION, {\n    operation: \"serializeTransaction\",\n    transactionType: transaction.type\n  });\n}\nfunction _parseEipSignature(tx, fields, serialize) {\n  try {\n    const recid = handleNumber(fields[0]).toNumber();\n    if (recid !== 0 && recid !== 1) {\n      throw new Error(\"bad recid\");\n    }\n    tx.v = recid;\n  } catch (error) {\n    logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n  }\n  tx.r = hexZeroPad(fields[1], 32);\n  tx.s = hexZeroPad(fields[2], 32);\n  try {\n    const digest = keccak256(serialize(tx));\n    tx.from = recoverAddress(digest, {\n      r: tx.r,\n      s: tx.s,\n      recoveryParam: tx.v\n    });\n  } catch (error) {}\n}\nfunction _parseEip1559(payload) {\n  const transaction = RLP.decode(payload.slice(1));\n  if (transaction.length !== 9 && transaction.length !== 12) {\n    logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n  }\n  const maxPriorityFeePerGas = handleNumber(transaction[2]);\n  const maxFeePerGas = handleNumber(transaction[3]);\n  const tx = {\n    type: 2,\n    chainId: handleNumber(transaction[0]).toNumber(),\n    nonce: handleNumber(transaction[1]).toNumber(),\n    maxPriorityFeePerGas: maxPriorityFeePerGas,\n    maxFeePerGas: maxFeePerGas,\n    gasPrice: null,\n    gasLimit: handleNumber(transaction[4]),\n    to: handleAddress(transaction[5]),\n    value: handleNumber(transaction[6]),\n    data: transaction[7],\n    accessList: accessListify(transaction[8])\n  };\n  // Unsigned EIP-1559 Transaction\n  if (transaction.length === 9) {\n    return tx;\n  }\n  tx.hash = keccak256(payload);\n  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n  return tx;\n}\nfunction _parseEip2930(payload) {\n  const transaction = RLP.decode(payload.slice(1));\n  if (transaction.length !== 8 && transaction.length !== 11) {\n    logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n  }\n  const tx = {\n    type: 1,\n    chainId: handleNumber(transaction[0]).toNumber(),\n    nonce: handleNumber(transaction[1]).toNumber(),\n    gasPrice: handleNumber(transaction[2]),\n    gasLimit: handleNumber(transaction[3]),\n    to: handleAddress(transaction[4]),\n    value: handleNumber(transaction[5]),\n    data: transaction[6],\n    accessList: accessListify(transaction[7])\n  };\n  // Unsigned EIP-2930 Transaction\n  if (transaction.length === 8) {\n    return tx;\n  }\n  tx.hash = keccak256(payload);\n  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n  return tx;\n}\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction) {\n  const transaction = RLP.decode(rawTransaction);\n  if (transaction.length !== 9 && transaction.length !== 6) {\n    logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n  }\n  const tx = {\n    nonce: handleNumber(transaction[0]).toNumber(),\n    gasPrice: handleNumber(transaction[1]),\n    gasLimit: handleNumber(transaction[2]),\n    to: handleAddress(transaction[3]),\n    value: handleNumber(transaction[4]),\n    data: transaction[5],\n    chainId: 0\n  };\n  // Legacy unsigned transaction\n  if (transaction.length === 6) {\n    return tx;\n  }\n  try {\n    tx.v = BigNumber.from(transaction[6]).toNumber();\n  } catch (error) {\n    // @TODO: What makes snese to do? The v is too big\n    return tx;\n  }\n  tx.r = hexZeroPad(transaction[7], 32);\n  tx.s = hexZeroPad(transaction[8], 32);\n  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n    // EIP-155 unsigned transaction\n    tx.chainId = tx.v;\n    tx.v = 0;\n  } else {\n    // Signed Transaction\n    tx.chainId = Math.floor((tx.v - 35) / 2);\n    if (tx.chainId < 0) {\n      tx.chainId = 0;\n    }\n    let recoveryParam = tx.v - 27;\n    const raw = transaction.slice(0, 6);\n    if (tx.chainId !== 0) {\n      raw.push(hexlify(tx.chainId));\n      raw.push(\"0x\");\n      raw.push(\"0x\");\n      recoveryParam -= tx.chainId * 2 + 8;\n    }\n    const digest = keccak256(RLP.encode(raw));\n    try {\n      tx.from = recoverAddress(digest, {\n        r: hexlify(tx.r),\n        s: hexlify(tx.s),\n        recoveryParam: recoveryParam\n      });\n    } catch (error) {}\n    tx.hash = keccak256(rawTransaction);\n  }\n  tx.type = null;\n  return tx;\n}\nexport function parse(rawTransaction) {\n  const payload = arrayify(rawTransaction);\n  // Legacy and EIP-155 Transactions\n  if (payload[0] > 0x7f) {\n    return _parse(payload);\n  }\n  // Typed Transaction (EIP-2718)\n  switch (payload[0]) {\n    case 1:\n      return _parseEip2930(payload);\n    case 2:\n      return _parseEip1559(payload);\n    default:\n      break;\n  }\n  return logger.throwError(\"unsupported transaction type: \".concat(payload[0]), Logger.errors.UNSUPPORTED_OPERATION, {\n    operation: \"parseTransaction\",\n    transactionType: payload[0]\n  });\n}","map":{"version":3,"names":["getAddress","BigNumber","arrayify","hexConcat","hexDataLength","hexDataSlice","hexlify","hexZeroPad","isBytesLike","splitSignature","stripZeros","Zero","keccak256","checkProperties","RLP","computePublicKey","recoverPublicKey","Logger","version","logger","TransactionTypes","handleAddress","value","handleNumber","from","transactionFields","name","maxLength","numeric","length","allowedTransactionKeys","chainId","data","gasLimit","gasPrice","nonce","to","type","computeAddress","key","publicKey","recoverAddress","digest","signature","formatNumber","result","toHexString","throwArgumentError","accessSetify","addr","storageKeys","address","map","storageKey","index","concat","toLowerCase","accessListify","Array","isArray","set","Object","keys","reduce","accum","sort","a","b","localeCompare","formatAccessList","_serializeEip1559","transaction","maxFeePerGas","eq","fields","maxPriorityFeePerGas","accessList","sig","push","recoveryParam","r","s","encode","_serializeEip2930","_serialize","raw","forEach","fieldInfo","options","hexPad","v","Math","floor","pop","serialize","throwError","errors","UNSUPPORTED_OPERATION","operation","transactionType","_parseEipSignature","tx","recid","toNumber","Error","error","_parseEip1559","payload","decode","slice","hash","_parseEip2930","_parse","rawTransaction","isZero","parse"],"sources":["E:\\Major Project\\satish\\M_project_blockchain\\node_modules\\@ethersproject\\transactions\\src.ts\\index.ts"],"sourcesContent":["\"use strict\";\r\n\r\nimport { getAddress } from \"@ethersproject/address\";\r\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\r\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\r\nimport { Zero } from \"@ethersproject/constants\";\r\nimport { keccak256 } from \"@ethersproject/keccak256\";\r\nimport { checkProperties } from \"@ethersproject/properties\";\r\nimport * as RLP from \"@ethersproject/rlp\";\r\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\n///////////////////////////////\r\n// Exported Types\r\n\r\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\r\n\r\n// Input allows flexibility in describing an access list\r\nexport type AccessListish = AccessList |\r\n                            Array<[ string, Array<string> ]> |\r\n                            Record<string, Array<string>>;\r\n\r\nexport enum TransactionTypes {\r\n    legacy = 0,\r\n    eip2930 = 1,\r\n    eip1559 = 2,\r\n};\r\n\r\nexport type UnsignedTransaction = {\r\n    to?: string;\r\n    nonce?: number;\r\n\r\n    gasLimit?: BigNumberish;\r\n    gasPrice?: BigNumberish;\r\n\r\n    data?: BytesLike;\r\n    value?: BigNumberish;\r\n    chainId?: number;\r\n\r\n    // Typed-Transaction features\r\n    type?: number | null;\r\n\r\n    // EIP-2930; Type 1 & EIP-1559; Type 2\r\n    accessList?: AccessListish;\r\n\r\n    // EIP-1559; Type 2\r\n    maxPriorityFeePerGas?: BigNumberish;\r\n    maxFeePerGas?: BigNumberish;\r\n}\r\n\r\nexport interface Transaction {\r\n    hash?: string;\r\n\r\n    to?: string;\r\n    from?: string;\r\n    nonce: number;\r\n\r\n    gasLimit: BigNumber;\r\n    gasPrice?: BigNumber;\r\n\r\n    data: string;\r\n    value: BigNumber;\r\n    chainId: number;\r\n\r\n    r?: string;\r\n    s?: string;\r\n    v?: number;\r\n\r\n    // Typed-Transaction features\r\n    type?: number | null;\r\n\r\n    // EIP-2930; Type 1 & EIP-1559; Type 2\r\n    accessList?: AccessList;\r\n\r\n    // EIP-1559; Type 2\r\n    maxPriorityFeePerGas?: BigNumber;\r\n    maxFeePerGas?: BigNumber;\r\n}\r\n\r\n///////////////////////////////\r\n\r\nfunction handleAddress(value: string): string {\r\n    if (value === \"0x\") { return null; }\r\n    return getAddress(value);\r\n}\r\n\r\nfunction handleNumber(value: string): BigNumber {\r\n    if (value === \"0x\") { return Zero; }\r\n    return BigNumber.from(value);\r\n}\r\n\r\n// Legacy Transaction Fields\r\nconst transactionFields = [\r\n    { name: \"nonce\",    maxLength: 32, numeric: true },\r\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\r\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\r\n    { name: \"to\",          length: 20 },\r\n    { name: \"value\",    maxLength: 32, numeric: true },\r\n    { name: \"data\" },\r\n];\r\n\r\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\r\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\r\n}\r\n\r\nexport function computeAddress(key: BytesLike | string): string {\r\n    const publicKey = computePublicKey(key);\r\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\r\n}\r\n\r\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\r\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\r\n}\r\n\r\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\r\n    const result = stripZeros(BigNumber.from(value).toHexString());\r\n    if (result.length > 32) {\r\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\r\n    return {\r\n        address: getAddress(addr),\r\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\r\n            if (hexDataLength(storageKey) !== 32) {\r\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\r\n            }\r\n            return storageKey.toLowerCase();\r\n        })\r\n    };\r\n}\r\n\r\nexport function accessListify(value: AccessListish): AccessList {\r\n    if (Array.isArray(value)) {\r\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\r\n            if (Array.isArray(set)) {\r\n                if (set.length > 2) {\r\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\r\n                }\r\n                return accessSetify(set[0], set[1])\r\n            }\r\n            return accessSetify(set.address, set.storageKeys);\r\n        });\r\n    }\r\n\r\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\r\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\r\n            accum[storageKey] = true;\r\n            return accum;\r\n        }, <Record<string, true>>{ });\r\n        return accessSetify(addr, Object.keys(storageKeys).sort())\r\n    });\r\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\r\n    return result;\r\n}\r\n\r\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\r\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\r\n}\r\n\r\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\r\n    // If there is an explicit gasPrice, make sure it matches the\r\n    // EIP-1559 fees; otherwise they may not understand what they\r\n    // think they are setting in terms of fee.\r\n    if (transaction.gasPrice != null) {\r\n        const gasPrice = BigNumber.from(transaction.gasPrice);\r\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\r\n        if (!gasPrice.eq(maxFeePerGas)) {\r\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\r\n                gasPrice, maxFeePerGas\r\n            });\r\n        }\r\n    }\r\n\r\n    const fields: any = [\r\n        formatNumber(transaction.chainId || 0, \"chainId\"),\r\n        formatNumber(transaction.nonce || 0, \"nonce\"),\r\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\r\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\r\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\r\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\r\n        formatNumber(transaction.value || 0, \"value\"),\r\n        (transaction.data || \"0x\"),\r\n        (formatAccessList(transaction.accessList || []))\r\n    ];\r\n\r\n    if (signature) {\r\n        const sig = splitSignature(signature);\r\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\r\n        fields.push(stripZeros(sig.r));\r\n        fields.push(stripZeros(sig.s));\r\n    }\r\n\r\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\r\n}\r\n\r\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\r\n    const fields: any = [\r\n        formatNumber(transaction.chainId || 0, \"chainId\"),\r\n        formatNumber(transaction.nonce || 0, \"nonce\"),\r\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\r\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\r\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\r\n        formatNumber(transaction.value || 0, \"value\"),\r\n        (transaction.data || \"0x\"),\r\n        (formatAccessList(transaction.accessList || []))\r\n    ];\r\n\r\n    if (signature) {\r\n        const sig = splitSignature(signature);\r\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\r\n        fields.push(stripZeros(sig.r));\r\n        fields.push(stripZeros(sig.s));\r\n    }\r\n\r\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\r\n}\r\n\r\n// Legacy Transactions and EIP-155\r\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\r\n    checkProperties(transaction, allowedTransactionKeys);\r\n\r\n    const raw: Array<string | Uint8Array> = [];\r\n\r\n    transactionFields.forEach(function(fieldInfo) {\r\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\r\n        const options: DataOptions = { };\r\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\r\n        value = arrayify(hexlify(value, options));\r\n\r\n        // Fixed-width field\r\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\r\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\r\n        }\r\n\r\n        // Variable-width (with a maximum)\r\n        if (fieldInfo.maxLength) {\r\n            value = stripZeros(value);\r\n            if (value.length > fieldInfo.maxLength) {\r\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\r\n            }\r\n        }\r\n\r\n        raw.push(hexlify(value));\r\n    });\r\n\r\n    let chainId = 0;\r\n    if (transaction.chainId != null) {\r\n        // A chainId was provided; if non-zero we'll use EIP-155\r\n        chainId = transaction.chainId;\r\n\r\n        if (typeof(chainId) !== \"number\") {\r\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\r\n        }\r\n\r\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\r\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\r\n        chainId = Math.floor((signature.v - 35) / 2);\r\n    }\r\n\r\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\r\n    if (chainId !== 0) {\r\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\r\n        raw.push(\"0x\");\r\n        raw.push(\"0x\");\r\n    }\r\n\r\n    // Requesting an unsigned transaction\r\n    if (!signature) {\r\n        return RLP.encode(raw);\r\n    }\r\n\r\n    // The splitSignature will ensure the transaction has a recoveryParam in the\r\n    // case that the signTransaction function only adds a v.\r\n    const sig = splitSignature(signature);\r\n\r\n    // We pushed a chainId and null r, s on for hashing only; remove those\r\n    let v = 27 + sig.recoveryParam\r\n    if (chainId !== 0) {\r\n        raw.pop();\r\n        raw.pop();\r\n        raw.pop();\r\n        v += chainId * 2 + 8;\r\n\r\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\r\n        if (sig.v > 28 && sig.v !== v) {\r\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\r\n        }\r\n    } else if (sig.v !== v) {\r\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\r\n    }\r\n\r\n    raw.push(hexlify(v));\r\n    raw.push(stripZeros(arrayify(sig.r)));\r\n    raw.push(stripZeros(arrayify(sig.s)));\r\n\r\n    return RLP.encode(raw);\r\n}\r\n\r\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\r\n    // Legacy and EIP-155 Transactions\r\n    if (transaction.type == null || transaction.type === 0) {\r\n        if (transaction.accessList != null) {\r\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\r\n        }\r\n        return _serialize(transaction, signature);\r\n    }\r\n\r\n    // Typed Transactions (EIP-2718)\r\n    switch (transaction.type) {\r\n        case 1:\r\n            return _serializeEip2930(transaction, signature);\r\n        case 2:\r\n            return _serializeEip1559(transaction, signature);\r\n        default:\r\n            break;\r\n    }\r\n\r\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\r\n        operation: \"serializeTransaction\",\r\n        transactionType: transaction.type\r\n    });\r\n}\r\n\r\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\r\n    try {\r\n        const recid = handleNumber(fields[0]).toNumber();\r\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\r\n        tx.v = recid;\r\n    } catch (error) {\r\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\r\n    }\r\n\r\n    tx.r = hexZeroPad(fields[1], 32);\r\n    tx.s = hexZeroPad(fields[2], 32);\r\n\r\n    try {\r\n        const digest = keccak256(serialize(tx));\r\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\r\n    } catch (error) { }\r\n}\r\n\r\nfunction _parseEip1559(payload: Uint8Array): Transaction {\r\n    const transaction = RLP.decode(payload.slice(1));\r\n\r\n    if (transaction.length !== 9 && transaction.length !== 12) {\r\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\r\n    }\r\n\r\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\r\n    const maxFeePerGas = handleNumber(transaction[3]);\r\n    const tx: Transaction = {\r\n        type:                  2,\r\n        chainId:               handleNumber(transaction[0]).toNumber(),\r\n        nonce:                 handleNumber(transaction[1]).toNumber(),\r\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\r\n        maxFeePerGas:          maxFeePerGas,\r\n        gasPrice:              null,\r\n        gasLimit:              handleNumber(transaction[4]),\r\n        to:                    handleAddress(transaction[5]),\r\n        value:                 handleNumber(transaction[6]),\r\n        data:                  transaction[7],\r\n        accessList:            accessListify(transaction[8]),\r\n    };\r\n\r\n    // Unsigned EIP-1559 Transaction\r\n    if (transaction.length === 9) { return tx; }\r\n\r\n    tx.hash = keccak256(payload);\r\n\r\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\r\n\r\n    return tx;\r\n}\r\n\r\nfunction _parseEip2930(payload: Uint8Array): Transaction {\r\n    const transaction = RLP.decode(payload.slice(1));\r\n\r\n    if (transaction.length !== 8 && transaction.length !== 11) {\r\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\r\n    }\r\n\r\n    const tx: Transaction = {\r\n        type:       1,\r\n        chainId:    handleNumber(transaction[0]).toNumber(),\r\n        nonce:      handleNumber(transaction[1]).toNumber(),\r\n        gasPrice:   handleNumber(transaction[2]),\r\n        gasLimit:   handleNumber(transaction[3]),\r\n        to:         handleAddress(transaction[4]),\r\n        value:      handleNumber(transaction[5]),\r\n        data:       transaction[6],\r\n        accessList: accessListify(transaction[7])\r\n    };\r\n\r\n    // Unsigned EIP-2930 Transaction\r\n    if (transaction.length === 8) { return tx; }\r\n\r\n    tx.hash = keccak256(payload);\r\n\r\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\r\n\r\n    return tx;\r\n}\r\n\r\n// Legacy Transactions and EIP-155\r\nfunction _parse(rawTransaction: Uint8Array): Transaction {\r\n    const transaction = RLP.decode(rawTransaction);\r\n\r\n    if (transaction.length !== 9 && transaction.length !== 6) {\r\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\r\n    }\r\n\r\n    const tx: Transaction = {\r\n        nonce:    handleNumber(transaction[0]).toNumber(),\r\n        gasPrice: handleNumber(transaction[1]),\r\n        gasLimit: handleNumber(transaction[2]),\r\n        to:       handleAddress(transaction[3]),\r\n        value:    handleNumber(transaction[4]),\r\n        data:     transaction[5],\r\n        chainId:  0\r\n    };\r\n\r\n    // Legacy unsigned transaction\r\n    if (transaction.length === 6) { return tx; }\r\n\r\n    try {\r\n        tx.v = BigNumber.from(transaction[6]).toNumber();\r\n\r\n    } catch (error) {\r\n        // @TODO: What makes snese to do? The v is too big\r\n        return tx;\r\n    }\r\n\r\n    tx.r = hexZeroPad(transaction[7], 32);\r\n    tx.s = hexZeroPad(transaction[8], 32);\r\n\r\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\r\n        // EIP-155 unsigned transaction\r\n        tx.chainId = tx.v;\r\n        tx.v = 0;\r\n\r\n    } else {\r\n        // Signed Transaction\r\n\r\n        tx.chainId = Math.floor((tx.v - 35) / 2);\r\n        if (tx.chainId < 0) { tx.chainId = 0; }\r\n\r\n        let recoveryParam = tx.v - 27;\r\n\r\n        const raw = transaction.slice(0, 6);\r\n\r\n        if (tx.chainId !== 0) {\r\n            raw.push(hexlify(tx.chainId));\r\n            raw.push(\"0x\");\r\n            raw.push(\"0x\");\r\n            recoveryParam -= tx.chainId * 2 + 8;\r\n        }\r\n\r\n        const digest = keccak256(RLP.encode(raw));\r\n        try {\r\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\r\n        } catch (error) { }\r\n\r\n        tx.hash = keccak256(rawTransaction);\r\n    }\r\n\r\n    tx.type = null;\r\n\r\n    return tx;\r\n}\r\n\r\n\r\nexport function parse(rawTransaction: BytesLike): Transaction {\r\n    const payload = arrayify(rawTransaction);\r\n\r\n    // Legacy and EIP-155 Transactions\r\n    if (payload[0] > 0x7f) { return _parse(payload); }\r\n\r\n    // Typed Transaction (EIP-2718)\r\n    switch (payload[0]) {\r\n        case 1:\r\n            return _parseEip2930(payload);\r\n        case 2:\r\n            return _parseEip1559(payload);\r\n        default:\r\n            break;\r\n    }\r\n\r\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\r\n        operation: \"parseTransaction\",\r\n        transactionType: payload[0]\r\n    });\r\n}\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}